## 迭代器模式与组合模式 ##


### 迭代器 ###
>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

第一个demo中，两个餐厅合并成一个餐厅，但两个餐厅菜单的实现方式不一样，一个是**ArrayList**，一个是**数组**，平常的做法，是服务员类拿到两个餐厅，分别遍历ArrayList和数组，遍历的方式也不一样，而且还暴露了餐厅内部的实现给服务员。

使用迭代器模式，规定一个方法来访问聚合对象，每个餐厅都需要实现自己的迭代器。

**Menu**这个类，让服务员不需要引用具体的餐厅类型，这是**面向接口编程**

 ##### 单一责任
 
 一个类应该只有一个引起变化的原因，尽量让每个类保持你单一责任。
 > 当一个模块或一个类被设计成只支持一组相关的功能时，我们说她具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说她具有低内聚
 
 
 ### 组合模式 ###
 >组合模式允许你讲对象组合成**树形结构**来表现"**整体/部分**"层次结构。组合能让客户以一致的方式处理个别对象以及对象组合
 
 在第二个例子中，菜单可以包含菜单项，也可以包含子菜单，子菜单也可以包含菜单项或子菜单，这个结构非常像多叉树。
 
 使用组合结构，我们能把相同的操作应用在组合和个别对象上，换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别
 
 为达成这个目的，我们需要有一个**组件基类**，这个类有个体和组合的所有操作，**个别对象**和**对象组合**都要继承于此类，分别实现自己应当实现的方法。
 
 #### Q？
 
 Q？ 我们之前还提到**单一责任**，但组合模式不仅要管理层次结构，还要执行菜单的操作，是不是已经违反了单一原则？

 A：  的确是的，组合模式**以单一责任原则换区透明性**，通过让组件的接口同时包含管理子节点和叶子节点的操作，客户就可以将组合和叶子节点一视同仁。也就是说，一个元素究竟是组合还是叶子节点，对客户是透明的。
 
 现在，我们的组件基类同时具有两种类型的操作。因为客户有机会对一个元素做一些不恰当的或是没有意义的操作（例如，把菜单项添加到菜单项中），所有我们失去了一些"安全性"。这是设计上的抉择。
 
 我们当然也可以采用另外一种方向的设计，将责任区分开来放在不同的接口中，这样一来，设计上就比较安全，但我们也因此失去了透明性，客户的代码将必须用条件语句和instanceof操作来处理不同类型的节点。
 
 回到问题，这是一个很典型的折中案例。尽管我们受到设计原则的指导，但是，**我们总是需要观察某原则对我们设计所造成的影响**。
 
 ####   组合最大的强项
 
让客户生活得更加简单，客户不再需要操心面对的是组合对象还是叶节点对象，所以就不用写一大堆if语句来保证他们对正确的对象调用了正确的方法。 